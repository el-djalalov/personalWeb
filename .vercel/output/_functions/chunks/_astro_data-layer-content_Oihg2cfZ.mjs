const _astro_dataLayerContent = [["Map",1,2,9,10],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.16.5","content-config-digest","6f4ea6f293865f58","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"https://www.elyor.dev\",\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"server\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":false,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":{\"type\":\"shiki\",\"excludeLangs\":[\"math\"]},\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[],\"rehypePlugins\":[],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true,\"allowedDomains\":[]},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"staticImportMetaEnv\":false,\"chromeDevtoolsWorkspace\":false,\"failOnPrerenderConflict\":false,\"svgo\":false},\"legacy\":{\"collections\":false}}","blog",["Map",11,12,30,31,47,48,63,64,78,79],"building-modern-web-applications-with-astro",{id:11,data:13,body:26,filePath:27,digest:28,deferredRender:29},{title:14,description:15,pubDate:16,author:17,heroImage:18,tags:19,draft:24,lang:25},"Building Modern Web Applications with Astro","Explore how Astro's innovative island architecture and content-first approach can help you build faster, more efficient websites with optimal performance.",["Date","2025-01-18T00:00:00.000Z"],"Elyor Djalalov","/images/blog/astro-framework.webp",[20,21,22,23],"Astro","Web Development","Performance","JavaScript",false,"en","In the ever-evolving landscape of web development, choosing the right framework can significantly impact your project's success. Today, I want to share my experience with **Astro** and why it has become my go-to choice for building content-focused websites.\n\n## Why Astro?\n\nAstro takes a fundamentally different approach compared to traditional JavaScript frameworks. Instead of shipping JavaScript to the browser by default, Astro generates static HTML and only hydrates interactive components when needed.\n\nThis \"islands architecture\" provides several key benefits:\n\n* **Zero JavaScript by default** - Pages load faster because there's no framework runtime\n* **Partial hydration** - Only interactive components get JavaScript\n* **Framework agnostic** - Use React, Vue, Svelte, or plain HTML in the same project\n* **Built-in optimizations** - Automatic image optimization, CSS bundling, and more\n\n## The Island Architecture Explained\n\nThink of your page as an ocean of static HTML, with small \"islands\" of interactivity scattered throughout. Each island is independent and can be hydrated on its own schedule.\n\n```astro\n---\n// This component only hydrates when visible in viewport\nimport Newsletter from '../components/Newsletter.tsx';\n---\n\n<article>\n  <h1>My Blog Post</h1>\n  <p>This is static HTML - no JavaScript needed!</p>\n\n  <!-- This island hydrates when scrolled into view -->\n  <Newsletter client:visible />\n</article>\n```\n\nThe `client:visible` directive tells Astro to wait until the component enters the viewport before loading its JavaScript. Other options include:\n\n* `client:load` - Hydrate immediately on page load\n* `client:idle` - Hydrate when the browser is idle\n* `client:media` - Hydrate when a media query matches\n* `client:only` - Skip SSR, only render on client\n\n## Content Collections: Type-Safe Content Management\n\nOne of my favorite Astro features is Content Collections. It provides a type-safe way to manage Markdown and MDX content with schema validation.\n\n```typescript\n// src/content.config.ts\nimport { defineCollection } from 'astro:content';\nimport { z } from 'astro/zod';\n\nconst blog = defineCollection({\n  schema: z.object({\n    title: z.string(),\n    description: z.string(),\n    pubDate: z.coerce.date(),\n    tags: z.array(z.string()),\n  }),\n});\n\nexport const collections = { blog };\n```\n\nThis schema ensures every blog post has the required frontmatter fields, catching errors at build time rather than runtime.\n\n## Performance Comparison\n\nI recently migrated a documentation site from Next.js to Astro. The results were impressive:\n\n| Metric                   | Next.js | Astro | Improvement    |\n| ------------------------ | ------- | ----- | -------------- |\n| First Contentful Paint   | 1.8s    | 0.6s  | 67% faster     |\n| Largest Contentful Paint | 2.4s    | 0.8s  | 67% faster     |\n| Total Blocking Time      | 450ms   | 0ms   | 100% reduction |\n| JavaScript Size          | 180KB   | 12KB  | 93% smaller    |\n\n## When to Choose Astro\n\nAstro excels in these scenarios:\n\n1. **Content-heavy websites** - Blogs, documentation, marketing sites\n2. **SEO-critical projects** - Static HTML means better crawlability\n3. **Performance-focused apps** - When every millisecond counts\n4. **Multi-framework teams** - Use React and Vue together seamlessly\n\nHowever, for highly interactive applications like dashboards or real-time collaboration tools, you might want to consider frameworks designed for that use case.\n\n## Getting Started\n\nReady to try Astro? Here's how to create a new project:\n\n```bash\n# Create a new project\nnpm create astro@latest my-blog\n\n# Navigate to the project\ncd my-blog\n\n# Start the development server\nnpm run dev\n```\n\nThe Astro CLI will guide you through the setup process, letting you choose templates, TypeScript support, and integrations.\n\n## Conclusion\n\nAstro represents a paradigm shift in how we think about web frameworks. By defaulting to static HTML and making JavaScript opt-in, it delivers exceptional performance without sacrificing developer experience.\n\nIf you're building a content-focused website and care about performance, I highly recommend giving Astro a try. The learning curve is minimal, especially if you're already familiar with modern JavaScript frameworks.\n\n***\n\n*Have questions about Astro or want to share your experience? [Let's connect](/#contact)!*","src/content/blog/building-modern-web-applications-with-astro.mdx","e0709ed5166a0e70",true,"engineering-behind-simple",{id:30,data:32,body:44,filePath:45,digest:46,deferredRender:29},{title:33,description:34,pubDate:35,author:17,heroImage:36,tags:37,draft:24,lang:25},"The Engineering Behind 'Simple'","A deep dive into Uber's distributed systems architecture - from real-time data syncing with gRPC over QUIC, to spatial matching with H3 hexagonal indexing, to smooth map animations using Kalman filters.",["Date","2025-01-18T00:00:00.000Z"],"/images/blog/uber-engineering.jpeg",[38,39,40,41,42,43],"System Design","Distributed Systems","gRPC","QUIC","H3","Software Engineering","When you open Uber, you see a map with moving cars. Simple, right?\n\nThat \"simple\" interface is actually one of the most complex distributed systems ever built. What fascinates me isn't the final architecture‚Äîit's **how they got there**. Every breakthrough came from hitting a wall that couldn't be patched around.\n\n## The Evolution of Real-Time Data Syncing\n\nTake data syncing. Early on, apps polled the server every few seconds asking \"anything new?\" At scale, millions of apps doing this becomes a **self-inflicted DDoS attack**.\n\nSo they flipped it‚Äî**Server-Sent Events** let the server push updates instead. Better. But SSE is one-way. The server couldn't know if critical driver offers actually arrived.\n\nThe real fix? **gRPC over QUIC/HTTP3**‚Äîtrue bidirectional streaming where both sides talk simultaneously. The result: **45% faster connections**.\n\n```\nTraditional Polling    ‚Üí    SSE (Push)    ‚Üí    gRPC/QUIC (Bidirectional)\n     ‚Üì                        ‚Üì                        ‚Üì\n   O(N√óM)               One-way only           True two-way streaming\n   queries              No delivery            With acknowledgments\n                        confirmation           45% faster\n```\n\n## The Spatial Matching Problem\n\nConsider the matching problem. N riders, M drivers‚Äîcalculating every possible distance is **O(N√óM)**. Impossible at scale.\n\nThe trick is **spatial partitioning**: divide the world into cells, only check nearby ones.\n\n![H3 hexagonal grid spatial partitioning](/images/blog/h3-hexagonal-grid.jpeg)\n\nBut here's the insight that surprised me‚Äî**why hexagons instead of squares?**\n\nBecause square corners are **41% farther from center than edges** (Corner Bias). Hexagons have uniform neighbor distances. Every neighbor cell is equidistant from the center.\n\nUber's **H3 index** now powers:\n- Dynamic pricing across different locations\n- ETA calculations\n- Driver positioning and dispatch optimization\n\n### The Math Behind Hexagons\n\n```\nSquare Grid:\n‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ   ‚îÇ d ‚îÇ   ‚îÇ    d = distance to edge neighbor\n‚îú‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚î§    d‚àö2 = distance to corner neighbor (41% farther!)\n‚îÇ d ‚îÇ X ‚îÇ d ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ   ‚îÇ d ‚îÇ   ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îò\n\nHexagonal Grid:\n    ‚ï±‚ï≤   ‚ï±‚ï≤\n   ‚ï±  ‚ï≤d‚ï±  ‚ï≤     All 6 neighbors are equidistant\n  ‚ï± d  ‚ï≤‚ï± d  ‚ï≤   No corner bias\n  ‚ï≤    ‚ï±X‚ï≤    ‚ï±   Uniform spatial queries\n   ‚ï≤  ‚ï±  ‚ï≤  ‚ï±\n    ‚ï≤‚ï± d  ‚ï≤‚ï±\n```\n\n## The Smoothness Illusion\n\nThen there's the **smoothness illusion**. GPS updates every ~4 seconds. Networks drop packets. Raw data would make cars teleport around the map.\n\nThe solution combines two techniques:\n\n1. **Dead Reckoning** - Predicting position from speed and heading between GPS updates\n2. **Kalman Filters** - Blending prediction and measurement, trusting GPS when strong, prediction when weak\n\n```typescript\n// Simplified Kalman filter concept\ninterface State {\n  position: [number, number];\n  velocity: [number, number];\n  uncertainty: number;\n}\n\nfunction update(state: State, gpsReading: Reading): State {\n  // Calculate Kalman gain based on GPS signal strength\n  const gain = state.uncertainty / (state.uncertainty + gpsReading.uncertainty);\n\n  // Blend prediction with measurement\n  const newPosition = [\n    state.position[0] + gain * (gpsReading.position[0] - state.position[0]),\n    state.position[1] + gain * (gpsReading.position[1] - state.position[1])\n  ];\n\n  return {\n    position: newPosition,\n    velocity: estimateVelocity(state, gpsReading),\n    uncertainty: (1 - gain) * state.uncertainty\n  };\n}\n```\n\nThe Kalman filter essentially asks: \"How much should I trust this new GPS reading vs. my prediction?\" When GPS signal is strong (low uncertainty), trust the reading. When it's weak (high uncertainty), trust the prediction.\n\n## The Pattern\n\nThe pattern repeats across every major system at Uber:\n\n1. **Start simple** - Polling, square grids, raw GPS\n2. **Hit a fundamental limit** - DDoS, O(N√óM), teleporting cars\n3. **Rethink entirely** - gRPC/QUIC, H3 hexagons, Kalman filters\n\nThat's real engineering. Not adding more servers to a broken architecture, but recognizing when the approach itself is the problem.\n\n---\n\n*The next time you open a \"simple\" app, remember: years of distributed systems research might be hiding behind that smooth interface.*\n\n*Have thoughts on distributed systems or want to discuss engineering patterns? [Let's connect](/#contact)!*","src/content/blog/engineering-behind-simple.mdx","882c6c8b43228efa","level-up-your-terminal-introducing-gemini-cli---your-ai-powered-coding-assistant-",{id:47,data:49,body:60,filePath:61,digest:62,deferredRender:29},{title:50,description:51,pubDate:52,author:17,heroImage:53,tags:54,draft:24,lang:25,translationKey:59},"Level Up Your Terminal: Introducing Gemini CLI - Your AI-Powered Coding Assistant ","Discover Gemini CLI, Google's new open-source AI agent that brings Gemini 2.5 Pro directly to your terminal with 1,000 free requests per day and seamless VS Code integration.  ",["Date","2025-08-15T15:28:07.653Z"],"/images/blog/Googles-Gemini-CLI.png",[55,56,57,58],"AI","CLI","Google","Developer Tools","gemini-cli","For developers, the command line is more than a tool‚Äîit's home. Now, that home gets a whole lot smarter with **Gemini CLI**, Google's new open-source AI agent that brings the power of Gemini 2.5 Pro directly to your terminal!\n\nGemini CLI provides lightweight access to Gemini, offering a versatile, local utility for everything from code understanding and file manipulation to dynamic troubleshooting and task automation.\n\n## What Makes Gemini CLI a Game-Changer?\n\n### Unmatched Usage Limits\n\nGet started **FREE** with a personal Google account and enjoy:\n\n* 60 requests per minute\n* 1,000 requests per day\n\nThat's an incredibly generous free tier for an AI tool of this caliber!\n\n### Seamless Integration\n\nBuilt-in integration with Google's AI coding assistant, **Gemini Code Assist**, provides a smooth transition between your terminal and VS Code. Switch effortlessly between environments while maintaining context and productivity.\n\n### Open and Extensible\n\nGemini CLI is fully **open-source** under the Apache 2.0 license. It supports the **Model Context Protocol (MCP)**, allowing for:\n\n* Deep customization\n* Community contributions\n* Integration with your existing workflows\n\n### Google Search Integration\n\nGround your prompts with real-time, external context directly from **Google Search**. This means your AI assistant can access up-to-date information while helping you code.\n\n## Who Is Gemini CLI For?\n\nGemini CLI empowers developers, builders, and creators to harness the power of AI in their daily workflows:\n\n* **Students** learning to code and wanting AI-assisted guidance\n* **Hobbyists** building side projects and experimenting with new technologies\n* **Professional developers** looking to boost productivity and automate repetitive tasks\n\nWhether you're debugging a complex issue, generating boilerplate code, or exploring a new codebase, Gemini CLI offers a fundamental upgrade to your command line experience.\n\n## Key Features at a Glance\n\n| Feature             | Description                            |\n| ------------------- | -------------------------------------- |\n| **Free Tier**       | 1,000 requests/day with Google account |\n| **Model**           | Gemini 2.5 Pro                         |\n| **License**         | Apache 2.0 (Open Source)               |\n| **IDE Integration** | VS Code via Gemini Code Assist         |\n| **Search**          | Built-in Google Search grounding       |\n| **Protocol**        | Model Context Protocol (MCP) support   |\n\n## Getting Started\n\nReady to upgrade your terminal? Here's how to get started:\n\n```bash\n# Install Gemini CLI\nnpm install -g @google/gemini-cli\n\n# Or using Homebrew on macOS\nbrew install gemini-cli\n\n# Start using it\ngemini \"Explain this error message\"\n```\n\n## Why This Matters\n\nThe terminal has always been the power user's domain. With Gemini CLI, Google is democratizing access to powerful AI capabilities right where developers spend most of their time. No need to switch contexts, open a browser, or leave your workflow‚Äîthe AI comes to you.\n\nThis is particularly exciting because:\n\n1. It's **free** with generous limits\n2. It's **open-source**, so the community can contribute and extend it\n3. It integrates with the tools we already use\n\n## Conclusion\n\nGemini CLI represents a significant step forward in making AI accessible to developers in their native environment. Whether you're a seasoned developer or just starting out, having an AI assistant in your terminal can dramatically improve your productivity and learning.\n\nGive it a try and let me know what you think!\n\n***\n\n**Resources:**\n\n* [Gemini CLI GitHub Repository](https://github.com/google-gemini/gemini-cli)\n* [Google AI Documentation](https://ai.google.dev/)","src/content/blog/level-up-your-terminal-introducing-gemini-cli---your-ai-powered-coding-assistant-.mdx","80ab92e45238dba9","elysiajs-bun-powered-backend-framework",{id:63,data:65,body:75,filePath:76,digest:77,deferredRender:29},{title:66,description:67,pubDate:68,author:17,heroImage:69,tags:70,draft:24,lang:25},"ElysiaJS ‚Äî The Bun-Powered Backend Framework That's Changing the Game","Discover ElysiaJS, an ergonomic web framework built for Bun runtime that combines Express-like simplicity with exceptional performance and end-to-end type safety.",["Date","2024-12-18T00:00:00.000Z"],"/images/blog/elysiajs-hero.png",[71,23,72,73,74,21],"TypeScript","Backend","Bun","ElysiaJS","If you're building APIs in JavaScript/TypeScript and haven't looked at ElysiaJS yet, you're missing out on something special.\n\n## What is ElysiaJS?\n\nElysia is an **ergonomic web framework** built specifically for the Bun runtime. It combines Express-like simplicity with exceptional performance and end-to-end type safety. The tagline says it all: *\"Ergonomic Framework for Humans\"*.\n\n## Why It Caught My Attention\n\n### Blazing Fast Performance\n\n![ElysiaJS Benchmark Results](/images/blog/elysiajs-benchmark.png)\n\nThe numbers speak for themselves:\n- **21x faster than Express**\n- **6x faster than Fastify**\n- **2,454,631 requests/second** in TechEmpower benchmarks\n\nTo put this in perspective, Elysia running on Bun rivals performance numbers typically seen only in Go and Rust frameworks. For a JavaScript/TypeScript framework, this is remarkable.\n\n```\nFramework Performance Comparison (requests/second):\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nElysia (Bun)    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  2,454,631\nGin (Go)        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà                    676,019\nSpring (Java)   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà                      506,087\nFastify (Node)  ‚ñà‚ñà‚ñà‚ñà‚ñà                       415,600\nExpress (Node)  ‚ñà                           113,117\nNest (Node)     ‚ñà                           105,064\n```\n\n### End-to-End Type Safety\n\nLike tRPC, but without the complexity. Types flow seamlessly from backend to frontend with **zero code generation**.\n\n```typescript\nimport { Elysia, t } from 'elysia'\n\nconst app = new Elysia()\n  .post('/user', ({ body }) => {\n    // body is fully typed as { name: string, email: string }\n    return {\n      id: crypto.randomUUID(),\n      ...body,\n      createdAt: new Date()\n    }\n  }, {\n    body: t.Object({\n      name: t.String(),\n      email: t.String({ format: 'email' })\n    })\n  })\n```\n\nThe schema defines validation AND types in one place. No duplication, no drift between runtime validation and TypeScript types.\n\n### OpenAPI Documentation in One Line\n\nJust add `.use(openapi())` and you have full API documentation. No annotations needed, no separate spec files to maintain:\n\n```typescript\nimport { Elysia } from 'elysia'\nimport { openapi } from '@elysiajs/openapi'\n\nconst app = new Elysia()\n  .use(openapi())  // That's it! Visit /swagger\n  .get('/health', () => 'OK')\n  .listen(3000)\n```\n\n### Bring Your Own Validator\n\nWorks with your favorite validation library:\n- **Zod** ‚Äî The most popular choice\n- **Valibot** ‚Äî Lightweight alternative\n- **ArkType** ‚Äî Fast and type-safe\n- **Effect** ‚Äî For functional programming enthusiasts\n\nAny Standard Schema compliant library works seamlessly while maintaining full type inference and OpenAPI compatibility.\n\n## Eden Treaty: Type-Safe Client\n\nOne of Elysia's killer features is **Eden Treaty** ‚Äî a type-safe client that syncs with your server automatically:\n\n```typescript\n// server.ts\nimport { Elysia, t } from 'elysia'\n\nexport const app = new Elysia()\n  .get('/posts', () => posts)\n  .post('/posts', ({ body }) => createPost(body), {\n    body: t.Object({\n      title: t.String(),\n      content: t.String()\n    })\n  })\n\nexport type App = typeof app\n```\n\n```typescript\n// client.ts\nimport { treaty } from '@elysiajs/eden'\nimport type { App } from './server'\n\nconst api = treaty<App>('localhost:3000')\n\n// Fully typed! IDE autocomplete works perfectly\nconst { data, error } = await api.posts.post({\n  title: 'Hello World',\n  content: 'My first post'\n})\n```\n\nNo code generation. No build step. Just import the type and go.\n\n## Real-World Example: REST API\n\nHere's a more complete example showing Elysia's ergonomic design:\n\n```typescript\nimport { Elysia, t } from 'elysia'\nimport { openapi } from '@elysiajs/openapi'\nimport { cors } from '@elysiajs/cors'\n\nconst app = new Elysia()\n  .use(openapi())\n  .use(cors())\n\n  // Group related routes\n  .group('/api/users', app => app\n    .get('/', async () => {\n      const users = await db.user.findMany()\n      return users\n    })\n\n    .get('/:id', async ({ params: { id } }) => {\n      const user = await db.user.findUnique({ where: { id } })\n      if (!user) throw new Error('User not found')\n      return user\n    }, {\n      params: t.Object({\n        id: t.String()\n      })\n    })\n\n    .post('/', async ({ body }) => {\n      return db.user.create({ data: body })\n    }, {\n      body: t.Object({\n        name: t.String({ minLength: 2 }),\n        email: t.String({ format: 'email' })\n      })\n    })\n  )\n\n  .listen(3000)\n\nconsole.log(`ü¶ä Elysia running at http://localhost:3000`)\n```\n\n## Built-in Features That Matter\n\n- **File uploads** with native validation\n- **WebSocket support** via ¬µWebSocket (the fastest WS library)\n- **Stream responses** using generator functions\n- **Static file serving** out of the box\n\n## Runtime Flexibility\n\nWhile Elysia is optimized for Bun, it's built on **Web Standards** and runs on:\n- Bun (recommended for best performance)\n- Node.js\n- Deno\n- Vercel Edge Functions\n\nNo vendor lock-in, despite Bun's performance advantages.\n\n## Getting Started\n\n```bash\n# Create a new project\nbun create elysia app\n\n# Or add to existing project\nbun add elysia\n```\n\n## Should You Use It?\n\n**Yes, if you:**\n- Want maximum performance from TypeScript\n- Value end-to-end type safety\n- Are already using or considering Bun\n- Build APIs and want automatic OpenAPI docs\n- Prefer ergonomic, minimal boilerplate code\n\n**Maybe wait if you:**\n- Need a battle-tested ecosystem (Elysia is newer)\n- Are heavily invested in Express middleware\n- Require enterprise support\n\n## Conclusion\n\nElysiaJS represents a new wave of backend frameworks that refuse to compromise. You get the developer experience of Express, the type safety of tRPC, the performance of Go, and the documentation of OpenAPI ‚Äî all in one package.\n\nThe project is community-driven, well-documented, and actively maintained. If you're exploring modern backend alternatives or experimenting with Bun, Elysia deserves a serious look.\n\n**Links:**\n- [Official Website](https://elysiajs.com)\n- [GitHub Repository](https://github.com/elysiajs/elysia)\n- [Documentation](https://elysiajs.com/introduction.html)\n\n---\n\n*What's your experience with Bun-based frameworks? Have you tried Elysia in production? [Let's connect](/#contact)!*","src/content/blog/elysiajs-bun-powered-backend-framework.mdx","f2affc61b4997165","react-server-components-deep-dive",{id:78,data:80,body:88,filePath:89,digest:90,deferredRender:29},{title:81,description:82,pubDate:83,author:17,heroImage:84,tags:85,draft:24,lang:25},"React Server Components: A Deep Dive","Understanding the revolutionary React Server Components pattern, how it differs from traditional SSR, and when to use them in your applications.",["Date","2025-01-15T00:00:00.000Z"],"/images/blog/react-components.jpg",[86,23,22,87],"React","Architecture","React Server Components (RSC) represent one of the most significant architectural shifts in React's history. Let's explore what they are, how they work, and why they matter.\n\n## The Problem RSC Solves\n\nTraditional React applications face a fundamental tension: we want rich, interactive UIs, but shipping large JavaScript bundles hurts performance. Server-Side Rendering (SSR) helps with initial load, but we still end up sending all that JavaScript for hydration.\n\nReact Server Components take a different approach: **some components never need to reach the client at all**.\n\n## Server Components vs Client Components\n\nUnderstanding the distinction is crucial:\n\n### Server Components (Default)\n\n```tsx\n// This runs ONLY on the server\nasync function BlogPost({ slug }) {\n  // Direct database access - no API needed!\n  const post = await db.posts.findUnique({\n    where: { slug },\n    include: { author: true }\n  });\n\n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <p>By {post.author.name}</p>\n      <div>{post.content}</div>\n    </article>\n  );\n}\n```\n\nServer Components can:\n- Access databases directly\n- Read from the filesystem\n- Use server-only secrets\n- Fetch data without waterfalls\n\nBut they **cannot**:\n- Use hooks (`useState`, `useEffect`)\n- Add event listeners\n- Use browser APIs\n\n### Client Components\n\n```tsx\n'use client';\n\nimport { useState } from 'react';\n\nfunction LikeButton({ postId, initialCount }) {\n  const [likes, setLikes] = useState(initialCount);\n\n  const handleLike = async () => {\n    setLikes(prev => prev + 1);\n    await fetch(`/api/posts/${postId}/like`, { method: 'POST' });\n  };\n\n  return (\n    <button onClick={handleLike}>\n      ‚ù§Ô∏è {likes} likes\n    </button>\n  );\n}\n```\n\nClient Components are the React you already know - they run in the browser and can be interactive.\n\n## The Composition Pattern\n\nThe real power emerges when you compose them together:\n\n```tsx\n// Server Component\nasync function PostPage({ params }) {\n  const post = await getPost(params.slug);\n  const comments = await getComments(params.slug);\n\n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <PostContent content={post.content} />\n\n      {/* Client Component for interactivity */}\n      <LikeButton postId={post.id} initialCount={post.likes} />\n\n      {/* Server-rendered comments list */}\n      <CommentsList comments={comments} />\n\n      {/* Client Component for new comment form */}\n      <NewCommentForm postId={post.id} />\n    </article>\n  );\n}\n```\n\n## Data Fetching Revolution\n\nWith RSC, data fetching becomes dramatically simpler:\n\n### Before: API Route + useEffect\n\n```tsx\n// Client Component (old way)\nfunction UserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    fetch(`/api/users/${userId}`)\n      .then(res => res.json())\n      .then(data => {\n        setUser(data);\n        setLoading(false);\n      });\n  }, [userId]);\n\n  if (loading) return <Skeleton />;\n  return <Profile user={user} />;\n}\n```\n\n### After: Direct Database Access\n\n```tsx\n// Server Component (new way)\nasync function UserProfile({ userId }) {\n  const user = await db.users.findUnique({\n    where: { id: userId }\n  });\n\n  return <Profile user={user} />;\n}\n```\n\nNo loading states. No API routes. No client-side data fetching. The data is fetched on the server and the fully rendered HTML is sent to the client.\n\n## Bundle Size Impact\n\nServer Components allow you to use heavy libraries without sending them to the client. Libraries like markdown parsers, syntax highlighters, and HTML sanitizers can run entirely on the server - potentially saving hundreds of kilobytes from your client bundle.\n\nFor example, a typical markdown processing pipeline might include:\n- Markdown parser: ~50KB\n- Syntax highlighter: ~180KB\n- HTML sanitizer: ~30KB\n\nWith Server Components, all 260KB stays on the server and never ships to the browser.\n\n## When to Use Each Type\n\n| Use Server Components When | Use Client Components When |\n|---------------------------|---------------------------|\n| Fetching data | Using React hooks |\n| Accessing backend resources | Handling user events |\n| Heavy library processing | Using browser APIs |\n| Keeping secrets secure | Managing local state |\n\n## Framework Support\n\nRSC is currently available in:\n\n- **Next.js 13+** (App Router)\n- **Gatsby 5** (experimental)\n- **Remix** (planned support)\n\n## Practical Tips\n\n1. **Start with Server Components** - Make everything a Server Component by default, add `'use client'` only when needed.\n\n2. **Push Client Components down** - Keep interactive parts as leaf nodes in your component tree.\n\n3. **Use Suspense wisely** - Wrap async Server Components in Suspense for better loading states.\n\n4. **Think in boundaries** - The `'use client'` directive creates a boundary - everything below it is also a Client Component.\n\n## Conclusion\n\nReact Server Components aren't just a performance optimization - they fundamentally change how we architect React applications. By moving rendering to the server by default, we get:\n\n- Smaller bundles\n- Faster initial loads\n- Direct backend access\n- Better security\n\nThe learning curve is worth it. This is where React is heading, and early adoption will pay dividends.\n\n---\n\n*Want to discuss RSC patterns or share your migration experience? [Let's connect](/#contact)!*","src/content/blog/react-server-components-deep-dive.mdx","5cb6e499ab3d3902"];

export { _astro_dataLayerContent as default };
